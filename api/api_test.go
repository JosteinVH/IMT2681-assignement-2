package api

import (
	. "IMT2681-assignement-2/data"
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestInfoHandler(t *testing.T) {

	/* Table of test cases*/
	tt := []struct {
		met        string
		url        string
		statusCode int
		expTime    string
		expInfo    string
		expVer     string
	}{
		{met: "GET", url: "http://localhost:8080/igcinfo/", statusCode: http.StatusNotFound},
		{met: "GET", url: "http://notworking.com/igcinfo/api", statusCode: http.StatusNotFound},
		{met: "GET", url: "http://localhost:8080/igcinfo/api/", statusCode: http.StatusOK, expTime: "PT0S", expInfo: "Service for IGC tracks.", expVer: "v1"},
	}

	for _, tc := range tt {
		req, err := http.NewRequest(tc.met, tc.url, nil)

		if err != nil {
			t.Fatalf("could not create request: %v", err)
		}
		rec := httptest.NewRecorder()

		InfoHandler(rec, req)

		// Returns response generated by handler
		res := rec.Result()
		defer res.Body.Close()
		if res.StatusCode != tc.statusCode {
			t.Errorf("Expected status %v: got %v", tc.statusCode, res.Status)
		}

		// Don't want to decode non-json
		if res.StatusCode == http.StatusNotFound {
			continue
		}

		var info Info
		if err := json.NewDecoder(res.Body).Decode(&info); err != nil {

			t.Fatalf("Could not decode json: %v", err)
		}

		if tc.expTime != info.Uptime {
			t.Errorf("Expected value: %v, got:  %v", tc.expTime, info.Uptime)
		}

		if tc.expInfo != info.Info {
			t.Errorf("Expected value: %v, got: %v", tc.expInfo, info.Uptime)
		}

		if tc.expVer != info.Version {
			t.Errorf("Expected value: %v,  got: %v ", tc.expVer, info.Version)
		}
	}
}

func TestGetAPI(t *testing.T) {

	tt := []struct {
		met        string
		url        string
		statusCode int
		lenOId     int
	}{
		{met: "GET", url: "http://localhost:8080/igcinfo/", statusCode: http.StatusOK, lenOId: 0},
		{met: "POST", url: "http://notworking.com/igcinfo/api", statusCode: http.StatusNotFound},
	}

	for _, tc := range tt {

		if tc.met == "GET" {

			req, err := http.NewRequest(tc.met, tc.url, nil)

			if err != nil {
				t.Errorf("Could not create request: %v", err)
			}
			rec := httptest.NewRecorder()

			GetAPI(rec, req)

			res := rec.Result()
			defer res.Body.Close()
			if res.StatusCode != tc.statusCode {
				t.Errorf("Expected statuscode %v, got %v", tc.statusCode, res.StatusCode)
			}

			var testId []int

			if err := json.NewDecoder(res.Body).Decode(&testId); err != nil {
				t.Fatalf("Could not parse json %v", err)
			}

			if len(testId) != tc.lenOId {
				t.Fatalf("Expected length %v, got %v", tc.lenOId, len(testId))
			}
		}

	}

}

/*
	Testing status code
*/
func TestIdHandler(t *testing.T) {
	tt := []struct {
		met        string
		url        string
		statusCode int
	}{
		{met: "GET", url: "localhost:8080/api/igc/1", statusCode: http.StatusNotFound},
		{met: "GET", url: "localhost:8080/api/igc/1/checksum/", statusCode: http.StatusNotFound},
		{met: "POST", url: "localhost:8080/api/igc/1/pilot/check", statusCode: http.StatusNotFound},
	}

	for _, tc := range tt {

		req, err := http.NewRequest(tc.met, tc.url, nil)
		if err != nil {
			t.Errorf("Could not make request %v", err)
		}

		rec := httptest.NewRecorder()

		IdHandler(rec, req)

		res := rec.Result()

		// Check is received status code corresponds to expected
		if res.StatusCode != tc.statusCode {
			t.Errorf("Expected statuscode: %v, got: %v", tc.statusCode, res.StatusCode)
		}
	}
}

/*
	Testing statuscode
*/

func TestPostApi(t *testing.T) {

	tt := []struct {
		met        string
		url        string
		statusCode int
		id         int
		body       map[string]string
	}{
		{met: "POST", url: "localhost:8080/api/igc", statusCode: http.StatusOK, id: 1},
	}

	for _, tc := range tt {

		tc.body = make(map[string]string)
		tc.body["url"] = "http://skypolaris.org/wp-content/uploads/IGS%20Files/Madrid%20to%20Jerez.igc"

		b, err := json.Marshal(&tc.body)
		if err != nil {
			t.Errorf("Could not marshal data %v", err)
		}

		buf := bytes.NewBuffer(b)

		req, err := http.NewRequest(tc.met, tc.url, buf)
		rec := httptest.NewRecorder()

		http.HandlerFunc(PostAPI).ServeHTTP(rec, req)
		res := rec.Result()

		// Check is received status code corresponds to expected
		if res.StatusCode != tc.statusCode {
			t.Errorf("Expected statuscode: %v, got: %v", tc.statusCode, res.StatusCode)
		}

		bytes, err := ioutil.ReadAll(res.Body)
		if err != nil {
			t.Errorf("Error")
		}

		var result TrackId

		if err := json.Unmarshal(bytes, &result); err != nil {
			t.Errorf("Error")
		}
		fmt.Println(result.Id)

		if result.Id != tc.id {
			t.Errorf("Expected Id: %v, got: %v", tc.id, result.Id)
		}
	}
}

func TestApiHandler(t *testing.T) {
	req, err := http.NewRequest("GET", "http://localhost:8080/igcinfo/api", nil)

	if err != nil {
		t.Fatalf("Could not create request: %v", err)
	}

	rec := httptest.NewRecorder()

	ApiHandler(rec, req)

	res := rec.Result()

	// Check is received status code corresponds to expected
	if res.StatusCode != http.StatusOK {
		t.Errorf("Expected status %v: got %v", http.StatusOK, res.StatusCode)
	}
}

func TestCheckHandler(t *testing.T) {

	tt := []struct {
		met        string
		url        string
		statusCode int
	}{
		{met: "GET", url: "localhost:8080/api/igc", statusCode: http.StatusOK},
	}

	for _, tc := range tt {

		req, err := http.NewRequest(tc.met, tc.url, nil)
		if err != nil {
			t.Fatalf("Could not create request")
		}

		var track Tracks = Tracks{
			H_date:       "123",
			Pilot:        "Michael",
			Glider:       "x2",
			GliderId:     "991",
			Track_length: 443,
		}

		rec := httptest.NewRecorder()

		CheckHandler(rec, req, track)

		res := rec.Result()

		// Check is received status code corresponds to expected
		if res.StatusCode != tc.statusCode {
			t.Errorf("Expected status %v, got: %v", tc.statusCode, res.StatusCode)
		}

		// Ugly check
		if tc.statusCode == http.StatusNotFound {
			continue
		}

		var testTrack Tracks
		if err := json.NewDecoder(res.Body).Decode(&testTrack); err != nil {
			t.Errorf("Could not decode json %v", err)
		}
	}
}
